from datetime import datetime
from pathlib import Path

from pydantic import BaseModel, ConfigDict, field_validator

from ..http_client import AsyncClient, Cookies
from ..utils import logger


class HTTPError(Exception):
    """HTTP error for compatibility."""

    pass


class GeneratedVideo(BaseModel):
    """
    Video generated by Gemini (Veo video generation). Returned when ask Gemini to "GENERATE a video of [something]".

    Parameters
    ----------
    url: `str`
        Download URL of the video (from contribution.usercontent.google.com).
    thumbnail_url: `str`, optional
        URL of the video thumbnail image.
    title: `str`, optional
        Title of the video, by default is "[Generated Video]".
    cookies: `dict | httpx.Cookies`
        Cookies used for requesting the content of the generated video, inherit from GeminiClient object or manually set.
        Should contain valid "__Secure-1PSID" and "__Secure-1PSIDTS" values.
    proxy: `str`, optional
        Proxy used when downloading video.
    """

    model_config = ConfigDict(arbitrary_types_allowed=True)

    url: str
    thumbnail_url: str = ""
    title: str = "[Generated Video]"
    cookies: dict[str, str] | Cookies
    proxy: str | None = None

    @field_validator("cookies", mode="after")
    @classmethod
    def validate_cookies(cls, v: dict[str, str] | Cookies) -> dict[str, str] | Cookies:
        if len(v) == 0:
            raise ValueError("GeneratedVideo is designed to be initialized with same cookies as GeminiClient.")
        return v

    def __str__(self):
        return f"GeneratedVideo(title='{self.title}', url='{(len(self.url) <= 40 and self.url) or self.url[:20] + '...' + self.url[-20:]}')"

    async def save(
        self,
        path: str = "temp",
        filename: str | None = None,
        cookies: dict | Cookies | None = None,
        verbose: bool = False,
    ) -> str | None:
        """
        Save the video to disk.

        Parameters
        ----------
        path: `str`, optional
            Path to save the video, by default will save to "./temp".
        filename: `str`, optional
            Filename to save the video. If not provided, will use timestamp + video.mp4.
        cookies: `dict`, optional
            Cookies used for requesting the content of the video. If not provided, will use the cookies from the GeneratedVideo instance.
        verbose : `bool`, optional
            If True, will print the path of the saved file, by default False.

        Returns
        -------
        `str | None`
            Absolute path of the saved video if successfully saved.

        Raises
        ------
        `HTTPError`
            If the network request failed.
        """

        # Generate a default filename if not provided
        if not filename:
            filename = f"{datetime.now().strftime('%Y%m%d%H%M%S')}_video.mp4"

        # Ensure filename has .mp4 extension
        if not filename.endswith(".mp4"):
            filename += ".mp4"

        headers = {
            "Origin": "https://gemini.google.com",
            "Referer": "https://gemini.google.com/",
        }

        # Add authuser param for Google video URLs
        download_url = self.url
        if "usercontent.google.com" in download_url and "authuser" not in download_url:
            if "?" in download_url:
                download_url += "&authuser=0"
            else:
                download_url += "?authuser=0"

        # Copy cookies with additional domains for Google video CDN
        download_cookies = Cookies()
        actual_cookies = cookies or self.cookies
        if actual_cookies:
            if isinstance(actual_cookies, dict):
                # Dict cookies - set for both google.com and usercontent.google.com
                for name, value in actual_cookies.items():
                    download_cookies.set(name, value, domain=".google.com")
                    download_cookies.set(name, value, domain=".usercontent.google.com")
            elif hasattr(actual_cookies, "jar"):
                # Cookies object with jar attribute
                for cookie in actual_cookies.jar:
                    download_cookies.set(cookie.name, cookie.value, domain=cookie.domain)
                    if cookie.domain and "google.com" in cookie.domain:
                        download_cookies.set(cookie.name, cookie.value, domain=".usercontent.google.com")
            else:
                # Assume it's already a Cookies object, copy it
                download_cookies = actual_cookies

        async with AsyncClient(http2=True, follow_redirects=True, headers=headers, cookies=download_cookies, proxy=self.proxy) as client:
            response = await client.get(download_url)

            if response.status_code == 200:
                content_type = response.headers.get("content-type", "")
                if "video" in content_type or "octet-stream" in content_type:
                    path = Path(path)
                    path.mkdir(parents=True, exist_ok=True)

                    dest = path / filename
                    dest.write_bytes(response.content)

                    if verbose:
                        logger.info(f"Video saved as {dest.resolve()}")

                    return str(dest.resolve())
                else:
                    logger.warning(f"Content type of {filename} is not video, but {content_type}.")

            reason = getattr(response, "reason_phrase", None) or getattr(response, "reason", "") or ""
            raise HTTPError(f"Error downloading video: {response.status_code} {reason}")

    async def save_thumbnail(
        self,
        path: str = "temp",
        filename: str | None = None,
        cookies: dict | Cookies | None = None,
        verbose: bool = False,
    ) -> str | None:
        """
        Save the video thumbnail to disk.

        Parameters
        ----------
        path: `str`, optional
            Path to save the thumbnail, by default will save to "./temp".
        filename: `str`, optional
            Filename to save the thumbnail. If not provided, will use timestamp + _thumb.jpg.
        cookies: `dict`, optional
            Cookies used for requesting the content of the thumbnail.
        verbose : `bool`, optional
            If True, will print the path of the saved file, by default False.

        Returns
        -------
        `str | None`
            Absolute path of the saved thumbnail if successfully saved.

        Raises
        ------
        `HTTPError`
            If the network request failed or no thumbnail URL available.
        """

        if not self.thumbnail_url:
            raise HTTPError("No thumbnail URL available for this video.")

        # Generate a default filename if not provided
        if not filename:
            filename = f"{datetime.now().strftime('%Y%m%d%H%M%S')}_thumb.jpg"

        headers = {
            "Origin": "https://gemini.google.com",
            "Referer": "https://gemini.google.com/",
        }

        # Copy cookies with additional domains
        download_cookies = Cookies()
        actual_cookies = cookies or self.cookies
        if actual_cookies:
            if isinstance(actual_cookies, dict):
                for name, value in actual_cookies.items():
                    download_cookies.set(name, value, domain=".google.com")
                    download_cookies.set(name, value, domain=".usercontent.google.com")
            elif hasattr(actual_cookies, "jar"):
                for cookie in actual_cookies.jar:
                    download_cookies.set(cookie.name, cookie.value, domain=cookie.domain)
                    if cookie.domain and "google.com" in cookie.domain:
                        download_cookies.set(cookie.name, cookie.value, domain=".usercontent.google.com")
            else:
                download_cookies = actual_cookies

        async with AsyncClient(http2=True, follow_redirects=True, headers=headers, cookies=download_cookies, proxy=self.proxy) as client:
            # Follow text-based redirect chain
            current_url = self.thumbnail_url
            max_redirects = 5
            response = None
            for _ in range(max_redirects):
                response = await client.get(current_url)
                if response.status_code != 200:
                    break
                content_type = response.headers.get("content-type", "")
                if "image" in content_type:
                    break
                if content_type.startswith("text/plain"):
                    new_url = response.text.strip()
                    if new_url.startswith("http"):
                        current_url = new_url
                    else:
                        break
                else:
                    break

            if response is not None and response.status_code == 200 and "image" in response.headers.get("content-type", ""):
                path = Path(path)
                path.mkdir(parents=True, exist_ok=True)

                dest = path / filename
                dest.write_bytes(response.content)

                if verbose:
                    logger.info(f"Thumbnail saved as {dest.resolve()}")

                return str(dest.resolve())
            else:
                reason = getattr(response, "reason_phrase", None) or getattr(response, "reason", "") or ""
                raise HTTPError(f"Error downloading thumbnail: {response.status_code} {reason}")
